---
layout: post
title:  C++知识点点滴记录
date: 2019-03-23
categories: c++
tags:  programming
author: Jason Chi
---
* content
{:toc}




1.在C++中，只要不明确指定是public，默认是private
2.virtual关键字主要是实现动态绑定。要触发动态绑定，必须满足两个条件：

    第一，指定为虚函数；

    第二，通过基类类型的引用或指针调用。

只要基函数定义了virtual，继承类的该函数也就具有virtual属性

纯虚函数为后代类提供可覆盖的接口，但这个类中的版本决不会调用。
含有（或继续）一个或多个纯虚函数的类是抽象基类，抽象基类不能实例化！

类对象的声明顺序与调用析构函数的顺序相反。如下，函数退出时先执行obj2析构函数，后执行obj1的。
```
int main()
{
    classA  obj1, obj2;

    return 0;
}
```

当类中没有定义复制构造函数时，编译器会自动创建一个默认按位复制的复制构造函数，它只会简单地把两个对象的成员变量做赋值运算，包括指针变量，这可能导致多次释放指针所指向空间的错误。

** 以下两个观点都是误解：**

a)   任何类如果没有定义构造函数，则编译器会帮我们合成一个默认构造函数。
b)   合成默认构造函数会对类中的每一个数据成员进行初始化。


只有在编译器需要默认构造函数来完成编译任务的时候，编译器才会为没有任何构造函数的类合成一个默认构造函数，或者是把这些操作插入到已有的构造函数中去。

编译器需要默认构造函数的四种情况，总结起来就是:

a)   调用对象成员或基类的默认构造函数。
b)   为对象初始化虚表指针与虚基类指针。

void func1 () const {}
这里const是指定该函数不会改变任何变量的值。

private成员变量，在构造函数中是可以被直接引用的，在初始化列表中或者构造函数体内都可以。

```
#ifdef __cplusplus
extern "C" {
#endif
void display (void)
{
printf ("This is a C code segment!\n");
}
#ifdef __cplusplus
}
#endif
```
选择private继承还是组合的原则：

　　尽可能使用组合，万不得已才用私有继承。



new一个对象时， 只为类中成员变量分配空间， 对象之间共享成员函数



g++为每个有虚函数的类在构造函数末尾中隐式的添加了为vptr赋值的操作

** 初始化列表的初始化顺序 **
初始化列表的初始化顺序与变量声明的顺序一致，而不是按照出现在初始化列表中的顺序。

** 给变量赋值使它所有位都为1 **
int i = ~0;

** #define 声明一年中有多少秒 **
#define SECONDS_PER_YEAR (365*24*60*60UL)

UL: unsigned long 无符号长整形

UL要跟数字连写，不能写到括号外面，否则编译错误



map与hashmap的区别

1.map底层数据结构是红黑树；hashmap底层数据结构是hash table
2.map优点是自动排序；hashmap优点是各项操作的平均时间复杂度接近常数
3.map是C++ STL一部分，而hashmap则还不是


sizeof:
是编译时运算符，编译时就确定了是编译时运算符，编译时就确定了
